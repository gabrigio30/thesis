NOTE CALL 3 DICEMBRE:
- Rimarrà utile anche tenere il fence e il nop perché a noi interessa il 'mix' di tutto, quindi non serve toglierli
- Implementa tutte le idee, quelle che vanno le metti in tesi, se alcune non funzionano proprio le abbandono, nella
    tesi, essendo tutto random, metterò un set di esperimenti largo con diversi setup mostrando i vari risultati
- Testa le trasformazioni singolarmente con 10, 20 e 50 varianti per finestra
- Mettere in maniera parametrica 'quante trasformazioni di ogni tipo usare per variante' e anche poter avere in %
    quanto di ogni trasformazione usare (e.g. 30% fence, 50% nop, 20% altro)


NOTE CALL 6 OTTOBRE
- Tira fuori delle statistiche di coverage dei branch/righe di codice in maniera strutturata cosi posso
  tirare fuori grafici e tabelle per dire ‘Non solo impedisco l’attacco, ma garantisco statisticamente che
  il programma modificato sia funzionalmente uguale al programma originale’
- Per coverage si intende usare qualche libreria o modulo python che ritorni delle statistiche precise di
  testing. (e.g. eseguito tutte le righe di codice, prendi entrambi i branch di un if, etc.).
  NON HO CAPITO SE SI RIFERISCE AL CODICE PYTHON O ALL’ASSEMBLY.
- Fai una verifica funzionale del codice e tienine traccia così alla fine nella tesi metteremo i Vbench(?) e
  per ciascuno la coverage che ho ottenuto
- Se avessi bisogno di altri attacchi cerca paper (e.g. spectre v1) che siano stati pubblicati su UNISEC così
  hanno associata la repository GitHub
- Fai software configurabile in modo che l’utente sia in grado di scegliere in base al nome a quali funzioni
  applicare le trasformazioni (non importante per ora)
- Fai codice parametrizzabile in maniera tale da poter scegliere quali trasformazioni attivare e quanto attivarle
- Assicurati che le trasformazioni sminchino il timing della cache (dicono no roba su registri)
- Scarica codice attacchi, esegui e verifica che tutto funzioni, dopodiché testa con il tool con le singole
  trasformazioni e verifica metriche (ha parlato di ‘quanti bit al secondo’)

LINK ATTACCHI IN C (cerca le stesse implementazioni ‘POC’ per Meltdown)
- https://github.com/tbodt/spectre/blob/master/
- https://github.com/crozone
- Link Assembly x86: https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html


NOTE CALL 27 OTTOBRE
- Aumenta il numero di run/round dello spectre per verificare se la forbice tra best e second best aumenta
- Risultato ideale: capire come varia il numero di run necessario per rubare l'informazione cone senza la mia tecnica,
    - quante run servono per rubare la scret key senza il mio programma (e.g. 100 run)?
    - con lo stesso numero di run (100) quanti bit rubo se la mia tecnica è applicata?
    - quante run servono per rubare tutta la secret key quando il mio tool è applicato?
- A runtime quando il programma incontra l'if che valuta il segreto deve avere possibilità (su un random value,
    e.g. orario) di poter accedere alle differenti varianti (segmenti di codice semanticamente equivalenti all'originale)

TESTO UTILE
Basati su questi due file che sono il mio parser, il mio detector attuali e il mio variant generator attuali:
- https://github.com/gabrigio30/thesis/blob/main/src/parser.py
- https://github.com/gabrigio30/thesis/blob/main/src/detector.py
- https://github.com/gabrigio30/thesis/blob/main/src/variant_generator.py

NOTE CALL 5 NOVEMBRE:
- Inserisci trasformazioni e verifica overhead (in modo statistico, fai un po' di run e vedi quanto ne introducono),
    sicurezza e correttezza funzionale di tutte
- C'è il round di training e il round dell'esecuzione per byte negli attacchi (quindi per il testing aumentali)
- Potrò mettere nella tesi che il tool è modulare e quindi si potranno inserire nuove trasformazioni e funzioni di detection
- Scarica coremark, genera l'assembly, passalo nel tool e poi esegui l'assembly di coremark per vedere quanto varia
    tra coremark eseguito 'normale' e coremark eseguito dopo essere passato nel tool


NOTE CALL 19 NOVEMBRE:
- Test: prendi istanza di spectre, testa unprotected, quanti byte del segreto rubo con quello e quanti con versione protected
- Nella narrativa della mia tesi farò l'estensione di LLVM, Amazon implementa il suo compilatore LLVM sul suo server, quindi
    tutti gli eseguibili eseguiti su quel server andranno prima ricompilati col mio tool (?)
- NON è necessario che le varianti che genero siano tutte diverse e uniche, perché saranno comunque in posizione (PC address)
    diversa tra loro